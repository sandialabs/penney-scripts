#! python3

"""A simple script to generate configurable C code of a queueing system."""

import sys
import os

class CodeMaker():
    counterType = "uint8_t"
    def __init__(self, itemName = "queueItem", filename = None):
        if "_t" in itemName:
            index = itemName.index("_t")
            itemName = itemName[:index]
        if filename == None:
            filename = "queue_{}".format(itemName)
        self.itemStem = itemName                        # Separate the item stem from any trailing _t
        self.itemName = self.itemStem + "_t"            # Tack the _t back on for type name
        self.functionStem = self.itemStem.upper() + "QUEUE"
        self.queueStem = self.itemStem + "_queue"
        self.macroLen = self.itemStem.upper() + "_QUEUE_ITEMS"  # Make a macro for queue length from the stem
        self.macroOk = self.itemStem.upper() + "_QUEUE_OK"
        self.macroFull = self.itemStem.upper() + "_QUEUE_FULL"
        self.macroEmpty = self.itemStem.upper() + "_QUEUE_EMPTY"
        self.filename = os.path.splitext(filename)[0] + ".c"
        self.header = os.path.splitext(filename)[0] + ".h"

    @staticmethod
    def section(text):
        return "// {:=^77}".format(" " + text + " ")

    def makeHeader(self):
        if self.header != None:
            fd = open(self.header, 'w')
        else:
            print("Using stdout")
            fd = sys.stdout
        self.makeHeaderHeader(fd)
        self.makeMacros(fd)
        self.makeExportedTypedefs(fd)
        self.makePrototypes(fd)
        self.makeHeaderFooter(fd)
        if fd != sys.stdout:
            fd.close()

    def makeSource(self):
        if self.filename != None:
            fd = open(self.filename, 'w')
        else:
            print("Using stdout")
            fd = sys.stdout
        self.makeSourceHeader(fd)
        self.makeTypedefs(fd)
        self.makeLocals(fd)
        print(self.section("Function Definitions"), file=fd)
        self.makeInit(fd)
        self.makeSet(fd)
        self.makeGet(fd)
        self.makeHelpers(fd)
        if fd != sys.stdout:
            fd.close()

    def makeSourceHeader(self, fd = None):
        print("/*  File: {0}\n *  Author: Auto-generated by {1}\n */\n".format(self.filename, sys.argv[0]), file=fd)
        print("#include \"{}\"\n".format(self.header), file=fd)

    def makeMacros(self, fd = None):
        print(self.section("Exported Macros"), file=fd)
        macros = ((self.macroLen, "8"),
                  (self.macroOk, "0x00"),
                  (self.macroFull, "0x01"),
                  (self.macroEmpty, "0x02")
                  )
        for mac, val in macros:
            print("#define {0:<40} {1:>8}".format(mac, "("+val+")"), file=fd)
        print(file=fd)

    def makeTypedefs(self, fd = None):
        print(self.section("Private Typedefs"), file=fd)
        print("typedef struct {{\n  {0} pIn;\n  {0} pOut;\n  {0} full;\n  {1} queue[{2}];\n}} {3}_t;\n".format(self.counterType,
                                                                                                                   self.itemName,
                                                                                                                   self.macroLen,
                                                                                                                   self.queueStem), file=fd)
        pass

    def makeLocals(self, fd = None):
        print(self.section("Private Variables"), file=fd)
        print("static {0}_t {0};\n".format(self.queueStem), file=fd)
        pass

    def makeInit(self, fd = None):
        print("void {0}_Init(void) {{\n  {1}.pIn = 0;\n  {1}.pOut = 0;\n  {1}.full = 0;\n  return;\n}}\n".format(self.functionStem,
                                                                                                                 self.queueStem), file=fd)

    def makeSet(self, fd = None):
        s = "uint8_t {0}_Add({1} *item) {{\n" \
            + "  // If full, return error\n" \
            + "  if ({2}.full) {{\n    return {3};\n  }}\n" \
            + "  // Copy item into queue\n" \
            + "  for (int n = 0; n < sizeof({1}); n++) {{\n    *((uint8_t *)&({2}.queue[{2}.pIn]) + n) = *((uint8_t *)item + n);\n  }}\n" \
            + "  // Wrap pIn at boundary\n" \
            + "  if ({2}.pIn == {4} - 1) {{\n    {2}.pIn = 0;\n  }} else {{\n    {2}.pIn++;\n  }}\n" \
            + "  // Check for full condition\n" \
            + "  if ({2}.pIn == {2}.pOut) {{\n    {2}.full = 1;\n  }}\n" \
            + "  return {5};\n" \
            + "}}\n"
        print(s.format(self.functionStem, self.itemName, self.queueStem, self.macroFull, self.macroLen, self.macroOk), file=fd)

    def makeGet(self, fd = None):
        s = "uint8_t {0}_Get(volatile {1} *item) {{\n" \
            + "  // Check for empty queue\n" \
            + "  if (({2}.pIn == {2}.pOut) && ({2}.full == 0)) {{\n    return {3};\n  }}\n" \
            + "  // Copy next data from the queue to item\n" \
            + "  for (int n = 0; n < sizeof({1}); n++) {{\n    *((uint8_t *)item + n) = *((uint8_t *)&({2}.queue[{2}.pOut]) + n);\n  }}\n" \
            + "  // Wrap pOut at boundary\n" \
            + "  if ({2}.pOut == {4} - 1) {{\n    {2}.pOut = 0;\n  }} else {{\n    {2}.pOut++;\n  }}\n" \
            + "  // Clear full condition\n" \
            + "  {2}.full = 0;\n" \
            + "  return {5};\n" \
            + "}}\n"
        print(s.format(self.functionStem, self.itemName, self.queueStem, self.macroEmpty, self.macroLen, self.macroOk), file=fd)

    def makeHelpers(self, fd = None):
        s = "uint8_t {0}_Status(void) {{\n" \
            + "  if (({1}.pIn == {1}.pOut) && ({1}.full == 0)) {{\n    return {2};\n  }}\n" \
            + "  if ({1}.full) {{\n    return {3};\n  }}\n" \
            + "  // If not full or empty, it is non-empty (at least one item in queue)\n" \
            + "  return {4};\n" \
            + "}}\n"
        print(s.format(self.functionStem, self.queueStem, self.macroEmpty, self.macroFull, self.macroOk), file=fd)

    def makeHeaderHeader(self, fd = None):
        print("/*  file: {0}\n *  Author: Auto-generated by {1}\n */\n".format(self.header, sys.argv[0]), file=fd)
        filestem = os.path.splitext(self.filename)[0]
        print("#ifndef __{0}_H\n#define __{0}_H\n".format(filestem.upper()), file=fd)
        print("#ifdef __cplusplus\nextern \"C\" {\n#endif\n", file=fd)
        print(self.section("Includes"), file=fd)
        print("#include <stdio.h>\n", file=fd)

    def makeExportedTypedefs(self, fd = None):
        print(self.section("Exported Typedefs"), file=fd)
        print("// Modify this definition to fit your application", file=fd)
        print("typedef uint8_t {};\n".format(self.itemName), file=fd)

    def makePrototypes(self, fd = None):
        print(self.section("Exported Function Prototypes"), file=fd)
        s = "void {0}_Init(void);\n" \
            + "uint8_t {0}_Add({1} *item);\n" \
            + "uint8_t {0}_Get(volatile {1} *item);\n" \
            + "uint8_t {0}_Status(void);\n"
        print(s.format(self.functionStem, self.itemName), file=fd)

    def makeHeaderFooter(self, fd = None):
        filestem = os.path.splitext(self.filename)[0]
        print("#ifdef __cplusplus\n}\n#endif\n", file=fd)
        print("#endif // __{0}_H\n".format(filestem.upper()), file=fd)

def makeCode(argv):
    USAGE = "python3 {} itemStem [fileName]".format(argv[0])
    if len(argv) < 2:
        print(USAGE)
        return False
    itemStem = None
    fileName = None
    for arg in argv[1:]:
        if itemStem != None:
            fileName = arg
        else:
            itemStem = arg
    mkr = CodeMaker(itemStem, fileName)
    mkr.makeSource()
    mkr.makeHeader()

if __name__ == "__main__":
    makeCode(sys.argv)

