#! /usr/bin/python3

# Plot a log file generated by logger.py

# TODO
#   * Plot each unit on its own panel

import os
import re
import matplotlib.pyplot as plt

class LogFile():
    _commentChar = "#"
    _itemDelimiter = '\t'
    _reUnits = "[^\(\)]*\(([^\(\)]*)\)"
    _regexpUnits = re.compile(_reUnits)
    _reTimeLabel = "Time|time|TIME"
    _regexpTimeLabel = re.compile(_reTimeLabel)

    # With len(markers) = 7, len(colors) = 9, there are 63 unique combinations which
    # will all be used in order
    _markers = ('.', 'o', '+', 'x', '^', '2', 'D')
    _colors = ('black', 'brown', 'red', 'orange', 'purple', 'green', 'blue', 'magenta', 'cyan')

    @staticmethod
    def _tryFloat(s):
        try:
            return float(s)
        except:
            pass
        try:
            # Maybe it's a hex string?
            return float(int(s, 16))
        except:
            pass
        return None

    @staticmethod
    def _identity(x):
        """Using this instead of a lambda for code consistency"""
        return x

    @classmethod
    def _isComment(cls, line):
        if not hasattr(line, '__len__'):
            return False
        if len(line) < 1:
            return False
        if line.strip()[0] == cls._commentChar:
            return True

    @classmethod
    def _deComment(cls, line):
        """Remove the leading comment char (if present) and leading/trailing whitespace"""
        return line.strip().lstrip(cls._commentChar).strip()

    @classmethod
    def _hasUnits(cls, s):
        """Return true if the string 's' has units parentheses like '(...)' """
        if cls._regexpUnits.match(s):
            return True
        else:
            return False

    @classmethod
    def _extractUnit(cls, s):
        #g = cls._regexpUnits.match(s)
        g = re.findall(cls._reUnits, s)
        if g:
            return g[-1]

    @classmethod
    def _getColorMarker(cls, index):
        m = cls._markers[index % len(cls._markers)]
        c = cls._colors[index % len(cls._colors)]
        return (c, m)

    def __init__(self, filename, sharedPlot = False):
        self.filename = filename
        self._sharedPlot = sharedPlot
        # The following is a comprehensive list of conversion
        # methods that yield plottable numeric data
        self._numericConverters = (self._tryFloat,)
        if self.read(filename):
            # Do other things
            pass

    def _convert(self, nCol, item):
        """Convert the data in column 'nCol' represented by string 'item' based on file
        specs."""
        if nCol > len(self._conversionSpecs) - 1:
            return None
        converter = self._conversionSpecs[nCol]
        return converter(item)

    def read(self, filename):
        self._commentStruct = []
        self._dataStruct = []
        self._headerString = ""
        self._dataColumns = 0
        self._dataRows = 0
        self._lineNo = 0
        self._ready = False
        if not os.path.exists(filename):
            print("File {} does not exist".format(filename))
            return False
        with open(filename, 'r') as fd:
            hline = fd.readline()
            line = fd.readline()
            self._lineNo = 2
            self._handleHeader(hline, line)
            while line:
                line = fd.readline()
                if not line:
                    break
                self._lineNo += 1
                if self._isComment(line):
                    self._handleComment(line)
                else:
                    self._handleData(line)
        self._ready = True

    def _makeConversionSpecs(self, dataLabels):
        self._conversionSpecs = []
        for n in range(len(dataLabels)):
            if self._hasUnits(dataLabels[n]):
                self._conversionSpecs.append(self._tryFloat)
            else:
                self._conversionSpecs.append(self._identity)

    def _handleHeader(self, line0, line1):
        self._headerString = self._deComment(line0)
        self._dataLabels = self._deComment(line1).split(self._itemDelimiter)
        self._dataColumns = len(self._dataLabels)
        self._makeConversionSpecs(self._dataLabels)
        return True

    def _handleComment(self, line):
        line = self._deComment(line)
        return True

    def _handleData(self, line):
        if not hasattr(line, '__len__'):
            return False
        if len(line) == 0:
            return False
        items = line.split(self._itemDelimiter)
        entries = [self._convert(n, items[n]) for n in range(len(items))]
        if len(entries) != self._dataColumns:
            print("Data column count does not match header column count. Line {}: {}".format(self._lineNo, line))
            return False
        self._dataStruct.append(entries)
        self._dataRows += 1
        return True

    def _dataColumnIsNumeric(self, index):
        """Return True if the data in column number 'index' is numeric in nature. Return False otherwise
        (e.g. if it is string/non-numeric information)."""
        if index > len(self._conversionSpecs) - 1:
            return False
        converter = self._conversionSpecs[index]
        if converter in self._numericConverters:
            return True
        return False

    def _getTimeIndex(self):
        for n in range(len(self._dataLabels)):
            if self._regexpTimeLabel.match(self._dataLabels[n]):
                return n
        return 0

    def _getCommonUnits(self, indexList):
        """Return a string of all the units of data designated by indices in
        'indexList'. Only returns one copy of each unique unit.  If all the
        units are the same, returns that unit."""
        unitStrings = self._getUnitList(indexList)
        return "(" + ', '.join(unitStrings) + ")"

    def _getUnitList(self, indexList):
        """Return a list of unique units used in data columns indicated by indices
        in 'indexList'."""
        unitStrings = []
        for index in indexList:
            label = self._dataLabels[index]
            unit = self._extractUnit(label)
            if unit not in unitStrings:
                unitStrings.append(unit)
        return unitStrings

    def plotByIndexByUnit(self, indexList):
        """Plot all channels denoted by indices in 'indexList', creating a unique
        subplot for each unit (shared x axis)."""
        if not self._ready:
            return False
        # Get data columns and labels as (time, val) pairs
        timeIndex = self._getTimeIndex()
        startTime = self._dataStruct[0][timeIndex]
        timeList = [x[timeIndex] - startTime for x in self._dataStruct]
        unitList = self._getUnitList(indexList)
        nSubplots = len(unitList)
        if nSubplots == 1:
            subplots = (plt.subplot(1, 1, 1),)
        else:
            fig, subplots = plt.subplots(nSubplots, sharex = True)
        subplotDict = {}
        #ax1 = plt.subplot(nSubplots, 1, 1)
        #subplotDict[unitList[0]] = ax1
        for n in range(nSubplots):
            #ax = plt.subplot(nSubplots, 1, n+1, sharex = ax1)
            ax = subplots[n]
            unit = unitList[n]
            subplotDict[unit] = ax
        print(subplotDict)
        for index in indexList:
            vals = [x[index] for x in self._dataStruct]
            label = self._dataLabels[index]
            unit = self._extractUnit(label)
            color, marker = self._getColorMarker(index)
            #ax = subplotDict.get(unit, None)
            index = unitList.index(unit)
            ax = subplots[index]
            #print("Plotting {} on subplot {}".format(label, index))
            if ax == None:
                print("Skipping {}".format(label))
                continue
            ax.plot(timeList, vals, color = color, marker = marker, label = label)
        plt.xlabel(self._dataLabels[timeIndex])
        for unit, ax in subplotDict.items():
            ax.legend()
            ax.grid(True)
            ax.set_ylabel(unit)
        plt.show()
        return True

    def plotByIndex(self, indexList):
        if self._sharedPlot:
            return self.plotByIndexShared(indexList)
        else:
            return self.plotByIndexByUnit(indexList)

    def plotByIndexShared(self, indexList):
        """Plot all channels denoted by indices in 'indexList'"""
        if not self._ready:
            return False
        #print("Plotting indices {}".format(indexList))
        # Get data columns and labels as (time, val) pairs
        timeIndex = self._getTimeIndex()
        startTime = self._dataStruct[0][timeIndex]
        timeList = [x[timeIndex] - startTime for x in self._dataStruct]
        for index in indexList:
            vals = [x[index] for x in self._dataStruct]
            label = self._dataLabels[index]
            color, marker = self._getColorMarker(index)
            #print("color = {}, marker = {}".format(color, marker))
            plt.plot(timeList, vals, color = color, marker = marker, label = label)
        plt.xlabel(self._dataLabels[timeIndex])
        plt.ylabel(self._getCommonUnits(indexList))
        plt.legend()
        plt.show()
        return True

    def plotAll(self):
        """Plot all plottable (numeric) data columns."""
        plotIndices = []
        timeIndex = self._getTimeIndex()
        for index in range(self._dataColumns):
            if index == timeIndex:
                # Don't plot time vs time
                continue
            if self._dataColumnIsNumeric(index):
                plotIndices.append(index)
        return self.plotByIndex(plotIndices)

    def plotByRegex(self, reStr):
        """Plot all channels matching regex string 'reStr'"""
        plotIndices = []
        regexp = re.compile(reStr)
        for index in range(self._dataColumns):
            label = self._dataLabels[index]
            if regexp.search(label):
                plotIndices.append(index)
        if len(plotIndices) == 0:
            print("No matching labels found")
            return False
        return self.plotByIndex(plotIndices)

    def plotByGlob(self, globStr):
        """Plot all channels matching glob string 'globStr'"""
        # TODO
        pass

    def plotByLabels(self, labelList):
        """Plot all channels denoted by labels in 'labelList'. Any labels that do not match exactly
        are ignored."""
        # TODO
        pass

    def setSharedPlot(self, isShared):
        if isShared:
            self._sharedPlot = True
        else:
            self._sharedPlot = False

    def __repr__(self):
        return "LogFile {}. {} lines. {} columns, {} rows of data.".format(self.filename,
                self._lineNo, self._dataColumns, self._dataRows)

    def __str__(self):
        return self.__repr__()

def testLogfile(argv):
    USAGE = "python3 {} filename".format(argv[0])
    if len(argv) < 2:
        print(USAGE)
        return False
    lf = LogFile(argv[1])
    print(lf)
    lf.plotAll()
    #tn = lf._getTimeIndex()
    #print("Time index found at {}".format(tn))
    return True

def plotByRegex(argv):
    USAGE = "python3 {} filename [reStr]".format(argv[0])
    if len(argv) < 2:
        print(USAGE)
        return False
    if len(argv) > 2:
        reStr = argv[2]
    else:
        reStr = "MOSFET"
    lf = LogFile(argv[1])
    lf.plotByRegex(reStr)
    return True

def test_hasUnits(argv):
    USAGE = "python3 {} s".format(argv[0])
    if len(argv) < 2:
        print(USAGE)
        return False
    if LogFile._hasUnits(argv[1]):
        print("Has units!")
    else:
        print("No units...")
    return True

def test_extractUnit(argv):
    USAGE = "python3 {} s".format(argv[0])
    if len(argv) < 2:
        print(USAGE)
        return False
    unit = LogFile._extractUnit(argv[1])
    print("Extracted unit: {}".format(unit))
    return True

if __name__ == "__main__":
    import sys
    #test_hasUnits(sys.argv)
    #test_extractUnit(sys.argv)
    #testLogfile(sys.argv)
    plotByRegex(sys.argv)
